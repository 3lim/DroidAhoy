/* listen.cpp */
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>
#include "listen.h"
#include <string.h>
#include <iostream>

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>

int window;
int anglex=0, angley=0, anglez=0;
char* recvData = new char[1024];
recvData[0] = '0';

int bindSock(uint16_t port)
{
	struct sockaddr_in sa;
	int sock;

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == -1) {
		return sock;
	}

	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.s_addr = INADDR_ANY;
	if (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		close(sock);
		return -1;
	}

	if (listen(sock, SOMAXCONN) == -1) {
		close(sock);
		return -1;
	}

	return sock;
}

void init(void)
{
	glClearColor (0.0, 0.0, 0.0, 0.0);
	glShadeModel (GL_FLAT);
}
void display(void)
{
	glClear (GL_COLOR_BUFFER_BIT);
	// glColor3f (1.0, 1.0, 1.0);
	glColor3f (0.0, 1.0, 0.0);
	glLoadIdentity (); /* clear the matrix */
	/* viewing transformation */
	// gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	gluLookAt (0.0, 0.0, 5.0, 0.6, 0.5, 0.0, 0.0, 1.0, 0.0);
	glScalef (1.0, 2.0, 1.0); /* modeling transformation */
	glRotatef( anglex, 1.0, 0.0, 0.0); //rotate about x-axis
	glRotatef(angley, 0.0, 1.0, 0.0); //rotate ablout y-axis
	glRotatef( anglez, 0.0, 0.0, 1.0); //rotate about z-axis
	glutWireCube (1.0);

	glColor3f( 1, 0, 0 );
	glRasterPos2f(0.1,0.1);

	for(int i = 0; recvData[i] != '\0'; i++)
	    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, recvData[i]);

	int i = 0;
	for( i < sizeof(recvData), i++)
	{
	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, recvData[i]);
}
	glFlush ();
}
void reshape (int w, int h)
{
	glViewport (0, 0, (GLsizei) w, (GLsizei) h);
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glFrustum (-1.0, 1.0,-1.0, 1.0, 1.5, 20.0);
	glMatrixMode (GL_MODELVIEW);
}
void keyboard ( unsigned char key, int x, int y)
{
	switch ( key ) {
	case 27:
		glutDestroyWindow(window);
	case 'x':
		anglex = ( anglex + 1 ) % 360;
		break;
	case 'X':
		anglex = ( anglex - 1 ) % 360;
		break;
	case 'y':
		angley = ( angley + 1 ) % 360;
		break;
	case 'Y':
		angley = ( angley - 1 ) % 360;
		break;
	case 'z':
		anglez = ( anglez + 1 ) % 360;
		break;
	case 'Z':
		anglez = ( anglez - 1 ) % 360;
		break;
	}
	glutPostRedisplay();
}

int main(int argc, char *argv[])
{
	glutInit(&argc, argv);
	glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize (500, 500);
	glutInitWindowPosition (100, 100);
	window =glutCreateWindow (argv[0]);
	init ();
	glutDisplayFunc(display);
	glutKeyboardFunc(keyboard);
	glutReshapeFunc(reshape);
	glutMainLoop();

	int listen, conn;

	listen = bindSock(4444);
	if (listen == -1) {
		fprintf(stderr, "bindSock error\n");
		return 1;
	}

	int bytes;

	while ((conn = accept(listen, NULL, NULL)) > 0) {

			bytes = recv(conn, recvData, recvData.sizeof(), 0);
			if (bytes == -1) {
				std::cout << "error on recv" << std::endl;
			}
			else {
				recvData[bytes] = '\0';
				std::cout << recvData << std::endl;
			}

		close(conn);
	}

	close(listen);

	return 1;
}


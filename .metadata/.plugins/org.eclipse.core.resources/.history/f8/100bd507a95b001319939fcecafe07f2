
/* PortListener.cpp */

#include "PortListener.h"

using namespace glm;

PortListener::PortListener(){
	int host_port= 1101;

	struct sockaddr_in my_addr;

	int hsock;
	int * p_int ;
	int err;

	socklen_t addr_size = 0;
	int* csock;
	sockaddr_in sadr;
	pthread_t thread_id=0;


	hsock = socket(AF_INET, SOCK_STREAM, 0);
	if(hsock == -1){
		printf("Error initializing socket %d\n", errno);
		goto FINISH;
	}

	p_int = (int*)malloc(sizeof(int));
	*p_int = 1;

	if( (setsockopt(hsock, SOL_SOCKET, SO_REUSEADDR, (char*)p_int, sizeof(int)) == -1 )||
			(setsockopt(hsock, SOL_SOCKET, SO_KEEPALIVE, (char*)p_int, sizeof(int)) == -1 ) ){
		printf("Error setting options %d\n", errno);
		free(p_int);
		goto FINISH;
	}
	free(p_int);

	my_addr.sin_family = AF_INET ;
	my_addr.sin_port = htons(host_port);

	memset(&(my_addr.sin_zero), 0, 8);
	my_addr.sin_addr.s_addr = INADDR_ANY ;

	if( bind( hsock, (sockaddr*)&my_addr, sizeof(my_addr)) == -1 ){
		fprintf(stderr,"Error binding to socket, make sure nothing else is listening on this port %d\n",errno);
		goto FINISH;
	}
	if(listen( hsock, 10) == -1 ){
		fprintf(stderr, "Error listening %d\n",errno);
		goto FINISH;
	}

	//Now lets do the server stuff

	addr_size = sizeof(sockaddr_in);

	while(true){
		printf("waiting for a connection\n");
		csock = (int*)malloc(sizeof(int));
		if((*csock = accept( hsock, (sockaddr*)&sadr, &addr_size))!= -1){
			printf("---------------------\nReceived connection from %s\n",inet_ntoa(sadr.sin_addr));
			pthread_create(&thread_id,0,&SocketHandler, (void*)csock );
			pthread_detach(thread_id);
		}
		else{
			fprintf(stderr, "Error accepting %d\n", errno);
		}
	}

	FINISH:
	;
}

void* PortListener::SocketHandler(void* lp){
	int *csock = (int*)lp;

	char buffer[1024];
	int buffer_len = 1024;
	int bytecount;

	memset(buffer, 0, buffer_len);
	if((bytecount = recv(*csock, buffer, buffer_len, 0))== -1){
		fprintf(stderr, "Error receiving data %d\n", errno);

		orientation = charToFloat(buffer);

		std::cout<< "Inside:" <<glm::to_string(orientation)<<std::endl;

		oldVector = orientation;

		goto FINISH;
	}
	printf("Received bytes %d\nReceived string \"%s\"\n", bytecount, buffer);
	strcat(buffer, " SERVER ECHO");

	/* No sending
	if((bytecount = send(*csock, buffer, strlen(buffer), 0))== -1){
		fprintf(stderr, "Error sending data %d\n", errno);
		goto FINISH;
	}

	printf("Sent bytes %d\n", bytecount);
*/

	FINISH:
	free(csock);
	return 0;
}

PortListener::~PortListener(){}
/*
int PortListener::bindSock(uint16_t port)
{
	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (sock == -1) {
		return sock;
	}

	struct sockaddr_in sa;

	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.s_addr = INADDR_ANY;

	if (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		close(sock);
		return -1;
	}

	if (listen(sock, SOMAXCONN) == -1) {
		close(sock);
		return -1;
	}

	return sock;
}

void PortListener::receiveData(){

	char* recvData = new char[1024];
	int bytes;

	boundsocket = bindSock(4444);

	if (boundsocket == -1) {
		fprintf(stderr, "bindSock error\n");
	}

	while ((conn = accept(boundsocket, NULL, NULL)) > 0) {

		bytes = recv(conn, recvData, 1023, 0);
		if (bytes == -1) {
			std::cout << "error on recv" << std::endl;
		}
		else {
			recvData[bytes] = '\0';

			orientation = charToFloat(recvData);

			std::cout<< "Inside:" <<glm::to_string(orientation)<<std::endl;

			oldVector = orientation;

		}

		close(conn);
	}

	close(boundsocket);

}

*/

glm::vec3 PortListener::charToFloat(char * characters){
	std::string tmp_s = characters;
	float * tmp_vf = new float[3];
	int place = 0;

	std::stringstream  ss;

	ss  << tmp_s;

	while( ! ss.eof() )
	{
		float  tmp_f;

		if ( ss >> tmp_f )
		{
			tmp_vf[place] = tmp_f;
			place++;
		}

	}

	//std::cout << tmp_vf[0] << tmp_vf[1] << tmp_vf[2] << std::endl;

	vec3 v(tmp_vf[0],tmp_vf[1],tmp_vf[2]);

	return v;
}
/*
void PortListener::startThread(){
    pthread_create(&thread, NULL, PortListener::receiveData, this);
}
 */
glm::vec3 PortListener::getVec(){
	return orientation;
}

int main(int argc, char *argv[])
{

	PortListener temp;
	/*
	pthread_t t1; // declare thread

	pthread_create( &t1, NULL, temp.&receiveData(),NULL); // create a thread running recievedData
	 */

	while(true){

		vec3 vertices = temp.getVec();
		std::cout<< "Outside:" <<glm::to_string(vertices)<<std::endl;

		sleep(1);

	}
	return 1;
}
